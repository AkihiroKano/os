#!/bin/bash
if [ $# -ne 1 ]; then
    echo "Ошибка: укажите имя файла." >&2
    exit 1
fi

target="$1"
trash_dir="$HOME/.trash"
log_file="$trash_dir/trash.log"

if [ ! -f "$log_file" ]; then
    echo "Ошибка: файл журнала не найден." >&2
    exit 1
fi

matches=()
while IFS='|' read -r original_path link_name; do
    name=$(basename "$original_path" | sed 's/\\ / /g')  # Восстановление пробелов
    if [ "$name" == "$target" ]; then
        matches+=("$original_path|$link_name")
    fi
done < <(sed 's/\\ / /g' "$log_file")  # Корректная обработка путей

if [ ${#matches[@]} -eq 0 ]; then
    echo "Файл '$target' не найден в корзине." >&2
    exit 1
fi

for entry in "${matches[@]}"; do
    IFS='|' read -r original_path link_name <<< "$entry"
    original_path=$(echo "$original_path" | sed 's/ /\\ /g')  # Экранирование для команд
    echo "Восстановить '$original_path'? [y/N]"
    read -r confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        restore_dir=$(dirname "$original_path")
        if [ ! -d "$restore_dir" ]; then
            restore_dir="$HOME"
            echo "Каталог не существует. Восстановление в $restore_dir."
        fi
        if [ -f "$restore_dir/$target" ]; then
            echo "Файл уже существует. Введите новое имя:"
            read -r new_name
            target="$new_name"
        fi
        # Экранирование имен
        ln "$trash_dir/$link_name" "$(echo "$restore_dir/$target" | sed 's/\\ / /g')" && rm "$trash_dir/$link_name" || { echo "Ошибка восстановления." >&2; exit 1; }
        sed -i "/$link_name/d" "$log_file"
        echo "Файл восстановлен в $(echo "$restore_dir/$target" | sed 's/\\ / /g')."
        exit 0
    fi
done
